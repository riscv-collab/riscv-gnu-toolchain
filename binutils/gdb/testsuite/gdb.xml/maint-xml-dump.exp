# Copyright 2020-2024 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Test the 'maint print xml-tdesc' command.  This file picks up every
# XML file matching the pattern maint-xml-dump-*.xml (in the same
# directory as this script) and passes each in turn to the command
# 'maint print xml-tdesc'.
#
# The expected output is generated by parsing the input XML file.  The
# rules for changing an XML file into the expected output are:
#
# 1. Blank lines, and lines starting with a comment are stripped from
#    the expected output.
#
# 2. The <?xml ... ?> and <!DOCTYPE ...> entities are optional,
#    suitable defaults will be added if these lines are missing from
#    the input file.
#
# 3. A trailing comment on a line will replace the expected output for
#    that line but with the indentation of the line preserved.  So
#    this (The '|' marks the start of the line):
#    |    <reg name="r1" bitsize="32"/>  <!-- <reg name="r1" bitsize="32" type="int" regnum="0"/> -->
#    Will actually look for the following output:
#    |    <reg name="r1" bitsize="32" type="int" regnum="0"/>
#
# 4. Indentation of lines will be preserved so your input file needs
#    to follow the expected indentation.
require allow_xml_test

gdb_start

# Read the XML file FILENAME and produce an output pattern that should
# match what GDB produces with the 'maint print xml-desc' command.
proc build_pattern { filename } {
    set pattern {}

    set xml_version_line {<?xml version="1.0"?>}
    set doc_type_line {<!DOCTYPE target SYSTEM "gdb-target.dtd">}

    set linenum 0
    set ifd [open "$filename" r]
    while {[gets $ifd line] >= 0} {
	incr linenum

	# The <?xml .... ?> tag can only appear as the first line in
	# the file.  If it is not present then add one to the expected
	# output now.
	if {$linenum == 1} {
	    if {![regexp {^<\?xml} $line]} {
		set pattern [string_to_regexp $xml_version_line]
		set xml_version_line ""
	    }
	}

	# If we have not yet seen a DOCTYPE line, then maybe we should
	# be adding one?  If we find <target> then add a default
	# DOCTYPE line, otherwise, if the XML file includes a DOCTYPE
	# line, use that.
	if {$doc_type_line != "" } {
	    if {[regexp {^[ \t]*<target>} $line]} {
		set pattern [multi_line $pattern \
				 [string_to_regexp $doc_type_line]]
		set doc_type_line ""
	    } elseif {[regexp {^[ \t]*<!DOCTYPE } $line]} {
		set doc_type_line ""
	    }
	}

	if {[regexp {^[ \t]*<!--} $line]} {
	    # Comment line, ignore it.
	} elseif {[regexp {^[ \t]+$} $line]} {
	    # Blank line, ignore it.
	} elseif {[regexp {^([ \t]*).*<!-- (.*) -->$} $line \
		       matches grp1 grp2]} {
	    set pattern [multi_line \
			     $pattern \
			     [string_to_regexp "$grp1$grp2"]]
	} else {
	    set pattern [multi_line \
			     $pattern \
			     [string_to_regexp $line]]
	}
    }
    close $ifd

    # Due to handling the <?xml ...?> tags we can end up with a stray
    # '\r\n' at the start of the output pattern.  Remove it here.
    if {[string range $pattern 0 1] == "\r\n"} {
	set pattern [string range $pattern 2 end]
    }

    return $pattern
}

# Run over every test XML file and check the output.
foreach filename [lsort [glob $srcdir/$subdir/maint-xml-dump-*.xml]] {
    set pattern [build_pattern $filename]

    if {[is_remote host]} {
	set test_path [remote_download host $filename]
    } else {
	set test_path $filename
    }

    verbose -log "Looking for:\n$pattern"

    gdb_test "maint print xml-tdesc $test_path" \
	"$pattern" "check [file tail $filename]"
}
