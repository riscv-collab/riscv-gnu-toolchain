// Simulator definition for the micromips ASE.
// Copyright (C) 2005-2024 Free Software Foundation, Inc.
// Contributed by Imagination Technologies, Ltd.
// Written by Andrew Bennett <andrew.bennett@imgtec.com>
//
// This file is part of the MIPS sim.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

:compute:::int:TBASE:BASE:((BASE < 2) ? (16 + BASE) \: BASE)
:compute:::int:TRD:RD:((RD < 2) ? (16 + RD) \: RD)
:compute:::int:TRS:RS:((RS < 2) ? (16 + RS) \: RS)
:compute:::int:TRT:RT:((RT < 2) ? (16 + RT) \: RT)
:compute:::int:TRT_S:RT_S:((RT_S == 1 ) ? 17 \: RT_S)
:compute:::int:ERT:RT:(compute_movep_src_reg (SD_, RT))
:compute:::int:ERS:RS:(compute_movep_src_reg (SD_, RS))

:compute:::int:IMM_DEC1:IMMEDIATE:((IMMEDIATE == 7) ? -1 \: ((IMMEDIATE == 0) ? 1 \: IMMEDIATE << 2))
:compute:::int:IMM_DEC2:IMMEDIATE:((IMMEDIATE < 8) ? IMMEDIATE \: (IMMEDIATE - 16))
:compute:::int:IMM_DEC3:IMMEDIATE:((IMMEDIATE < 2) ? IMMEDIATE + 256 \: ((IMMEDIATE < 256) ? IMMEDIATE \: ((IMMEDIATE < 510) ? IMMEDIATE - 512 \: IMMEDIATE - 768)))
:compute:::int:IMM_DEC4:IMMEDIATE:(compute_andi16_imm (SD_, IMMEDIATE))
:compute:::int:IMM_DEC5:IMMEDIATE:((IMMEDIATE < 15) ? IMMEDIATE \: -1)
:compute:::int:IMM_DEC6:IMMEDIATE:((IMMEDIATE < 127) ? IMMEDIATE \: -1)

:compute:::int:SHIFT_DEC:SHIFT:((SHIFT == 0) ? 8 \: SHIFT)

:compute:::int:IMM_SHIFT_1BIT:IMMEDIATE:(IMMEDIATE << 1)
:compute:::int:IMM_SHIFT_2BIT:IMMEDIATE:(IMMEDIATE << 2)

:function:::address_word:delayslot_micromips:address_word target, address_word nia, int delayslot_instruction_size
*micromips32:
*micromips64:
*micromipsdsp:
{
  instruction_word delay_insn;
  sim_events_slip (SD, 1);
  DSPC = CIA;
  CIA = nia;
  STATE |= simDELAYSLOT;
  ENGINE_ISSUE_PREFIX_HOOK();
  micromips_instruction_decode (SD, CPU, CIA, delayslot_instruction_size);
  STATE &= ~simDELAYSLOT;
  return target;
}

:function:::address_word:process_isa_mode:address_word target
*micromips32:
*micromips64:
{
  struct mips_sim_state *state = MIPS_SIM_STATE (SD);
  state->isa_mode = target & 0x1;
  return (target & (-(1 << 1)));
}

:function:::address_word:do_micromips_jalr:int rt, int rs, address_word nia, int delayslot_instruction_size
*micromips32:
*micromips64:
{
  GPR[rt] = (nia + delayslot_instruction_size) | ISA_MODE_MICROMIPS;
  return (process_isa_mode (SD_,
	delayslot_micromips (SD_, GPR[rs], nia, delayslot_instruction_size)));
}

:function:::address_word:do_micromips_jal:address_word target, address_word nia, int delayslot_instruction_size
*micromips32:
*micromips64:
{
  RA = (nia + delayslot_instruction_size) | ISA_MODE_MICROMIPS;
  return delayslot_micromips (SD_, target, nia, delayslot_instruction_size);
}


:function:::uint32_t:compute_movep_src_reg:int reg
*micromips32:
*micromips64:
{
  switch (reg)
    {
    case 0: return 0;
    case 1: return 17;
    case 2: return 2;
    case 3: return 3;
    case 4: return 16;
    case 5: return 18;
    case 6: return 19;
    case 7: return 20;
    default: return 0;
    }
}

:function:::uint32_t:compute_andi16_imm:int encoded_imm
*micromips32:
*micromips64:
{
  switch (encoded_imm)
    {
    case 0: return 128;
    case 1: return 1;
    case 2: return 2;
    case 3: return 3;
    case 4: return 4;
    case 5: return 7;
    case 6: return 8;
    case 7: return 15;
    case 8: return 16;
    case 9: return 31;
    case 10: return 32;
    case 11: return 63;
    case 12: return 64;
    case 13: return 255;
    case 14: return 32768;
    case 15: return 65535;
    default: return 0;
    }
}

:function:::FP_formats:convert_fmt_micromips:int fmt
*micromips32:
*micromips64:
{
  switch (fmt)
    {
    case 0: return fmt_single;
    case 1: return fmt_double;
    case 2: return fmt_ps;
    default: return fmt_unknown;
    }
}

:function:::FP_formats:convert_fmt_micromips_cvt_d:int fmt
*micromips32:
*micromips64:
{
  switch (fmt)
    {
    case 0: return fmt_single;
    case 1: return fmt_word;
    case 2: return fmt_long;
    default: return fmt_unknown;
    }
}


:function:::FP_formats:convert_fmt_micromips_cvt_s:int fmt
*micromips32:
*micromips64:
{
  switch (fmt)
    {
    case 0: return fmt_double;
    case 1: return fmt_word;
    case 2: return fmt_long;
    default: return fmt_unknown;
    }
}


011011,3.RD,6.IMMEDIATE,1:POOL16E:16::ADDIUR1SP
"addiur1sp r<TRD>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_addiu (SD_, SPIDX, TRD, IMMEDIATE << 2);
}


011011,3.RD,3.RS,3.IMMEDIATE,0:POOL16E:16::ADDIUR2
"addiur2 r<TRD>, r<TRS>, <IMM_DEC1>"
*micromips32:
*micromips64:
{
  do_addiu (SD_, TRS, TRD, IMM_DEC1);
}


010011,5.RD,4.IMMEDIATE,0:POOL16D:16::ADDIUS5
"addius5 r<RD>, <IMM_DEC2>"
*micromips32:
*micromips64:
{
  do_addiu (SD_, RD, RD, IMM_DEC2);
}


010011,9.IMMEDIATE,1:POOL16D:16::ADDIUSP
"addiusp <IMM_DEC3>"
*micromips32:
*micromips64:
{
  do_addiu (SD_, SPIDX, SPIDX, IMM_DEC3 << 2);
}


000001,3.RD,3.RT,3.RS,0:POOL16A:16::ADDU16
"addu16 r<TRD>, r<TRS>, r<TRT>"
*micromips32:
*micromips64:
{
  do_addu (SD_, TRS, TRT, TRD);
}


001011,3.RD,3.RS,4.IMMEDIATE:MICROMIPS:16::ANDI16
"andi16 r<TRD>, r<TRS>, <IMM_DEC4>"
*micromips32:
*micromips64:
{
  do_andi (SD_, TRS, TRD, IMM_DEC4);
}


010001,0010,3.RT,3.RS:POOL16C:16::AND16
"and16 r<TRT>, r<TRS>"
*micromips32:
*micromips64:
{
  do_and (SD_, TRS, TRT, TRT);
}


110011,10.IMMEDIATE:MICROMIPS:16::B16
"b16 <IMMEDIATE>"
*micromips32:
*micromips64:
{
  NIA = delayslot_micromips (SD_, NIA + (EXTEND11 (IMMEDIATE << 1)),
				  NIA, MICROMIPS_DELAYSLOT_SIZE_ANY);
}


100011,3.RS,7.IMMEDIATE:MICROMIPS:16::BEQZ16
"beqz16 r<TRS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  if (GPR[TRS] == 0)
    NIA = delayslot_micromips (SD_, NIA + (EXTEND8 (IMMEDIATE << 1)),
				    NIA, MICROMIPS_DELAYSLOT_SIZE_ANY);
}


101011,3.RS,7.IMMEDIATE:MICROMIPS:16::BNEZ16
"bnez16 r<TRS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  if (GPR[TRS] != 0)
    NIA = delayslot_micromips (SD_, NIA + (EXTEND8 (IMMEDIATE << 1)),
				    NIA, MICROMIPS_DELAYSLOT_SIZE_ANY);
}


010001,101000,4.CODE:POOL16C:16::BREAK16
"break16 %#lx<CODE>"
*micromips32:
*micromips64:
{
  do_break16 (SD_, instruction_0);
}


010001,01110,5.RS:POOL16C:16::JALR16
"jalr16 r<RS>"
*micromips32:
*micromips64:
{
  NIA = do_micromips_jalr (SD_, RAIDX, RS, NIA, MICROMIPS_DELAYSLOT_SIZE_32);
}


010001,01111,5.RS:POOL16C:16::JALRS16
"jalrs16 r<RS>"
*micromips32:
*micromips64:
{
  NIA = do_micromips_jalr (SD_, RAIDX, RS, NIA, MICROMIPS_DELAYSLOT_SIZE_16);
}


010001,01100,5.RS:POOL16C:16::JR16
"jr16 r<RS>"
*micromips32:
*micromips64:
{
  NIA = process_isa_mode (SD_,
	delayslot_micromips (SD_, GPR[RS], NIA, MICROMIPS_DELAYSLOT_SIZE_ANY));
}


010001,11000,5.IMMEDIATE:POOL16C:16::JRADDIUSP
"jraddiusp <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word temp = RA;
  do_addiu (SD_, SPIDX, SPIDX, IMMEDIATE << 2);
  NIA = process_isa_mode (SD_, temp);
}


010001,01101,5.RS:POOL16C:16::JRC
"jrc r<RS>"
*micromips32:
*micromips64:
{
  NIA = process_isa_mode (SD_, GPR[RS]);
}


000010,3.RT,3.BASE,4.IMMEDIATE:MICROMIPS:16::LBU16
"lbu16 r<TRT>, <IMM_DEC5>(r<TBASE>)"
*micromips32:
*micromips64:
{
  /* LBU can have a negative offset.  As the offset argument to do_load is
     unsigned we need to do the address calcuation before the function call so
     that the load address has been correctly calculated */

  GPR[TRT] = do_load (SD_, AccessLength_BYTE, GPR[TBASE] + IMM_DEC5, 0);
}


001010,3.RT,3.BASE,4.IMMEDIATE:MICROMIPS:16::LHU16
"lhu16 r<TRT>, <IMM_SHIFT_1BIT>(r<TBASE>)"
*micromips32:
*micromips64:
{
  GPR[TRT] = do_load (SD_, AccessLength_HALFWORD, GPR[TBASE], IMM_SHIFT_1BIT);
}


111011,3.RD,7.IMMEDIATE:MICROMIPS:16::LI16
"li16 r<TRD>, <IMM_DEC6>"
*micromips32:
*micromips64:
{
  GPR[TRD] = IMM_DEC6;
}


011010,3.RT,3.BASE,4.IMMEDIATE:MICROMIPS:16::LW16
"lw16 r<TRT>, <IMM_SHIFT_2BIT>(r<TBASE>)"
*micromips32:
*micromips64:
{
  GPR[TRT] = EXTEND32 (
	do_load (SD_, AccessLength_WORD, GPR[TBASE], IMM_SHIFT_2BIT));
}

:%s::::LWMREGS:int lwmregs
*micromips32:
*micromips64:
{
  if (lwmregs == 3)
    return "s0, s1, s2, s3, ra";
  else if (lwmregs == 2)
    return "s0, s1, s2, ra";
  else if (lwmregs == 1)
    return "s0, s1, ra";
  else if (lwmregs == 0)
    return "s0, ra";
  else
    return "";
}

010001,0100,2.LWMREGS,4.IMMEDIATE:POOL16C:16::LWM16
"lwm16 %s<LWMREGS>, <IMM_SHIFT_2BIT>(sp)"
*micromips32:
*micromips64:
{
  int address = GPR[SPIDX] + IMM_SHIFT_2BIT;
  int reg_offset;

  for (reg_offset = 0; reg_offset <= LWMREGS; reg_offset++)
    GPR[16 + reg_offset] = EXTEND32 (
	do_load (SD_, AccessLength_WORD, address, reg_offset * 4));

  RA = EXTEND32 (do_load (SD_, AccessLength_WORD, address, reg_offset * 4));
}


011001,3.RT,7.IMMEDIATE:MICROMIPS:16::LWGP
"lwgp r<TRT>, <IMM_SHIFT_2BIT>(gp)"
*micromips32:
*micromips64:
{
  GPR[TRT] = EXTEND32 (
	do_load (SD_, AccessLength_WORD, GPR[28], IMM_SHIFT_2BIT));
}


010010,5.RT,5.IMMEDIATE:MICROMIPS:16::LWSP
"lwsp r<RT>, <IMM_SHIFT_2BIT>(sp)"
*micromips32:
*micromips64:
{
  GPR[RT] = EXTEND32 (do_load (SD_, AccessLength_WORD, SP, IMM_SHIFT_2BIT));
}


010001,10000,5.RD:POOL16C:16::MFHI16
"mfhi16 r<RD>"
*micromips32:
*micromips64:
{
  do_mfhi (SD_, RD);
}


010001,10010,5.RD:POOL16C:16::MFLO16
"mflo16 r<RD>"
*micromips32:
*micromips64:
{
  do_mflo (SD_, RD);
}


000011,5.RD,5.RS:MICROMIPS:16::MOVE16
"nop":RD==0&&RS==0
"move16 r<RD>, r<RS>"
*micromips32:
*micromips64:
{
  GPR[RD] = GPR[RS];
}


:%s::::DESTREGS:int regs
*micromips32:
*micromips64:
{
  switch (regs)
    {
    case 0: return "a1, a2,";
    case 1: return "a1, a3,";
    case 2: return "a2, a3,";
    case 3: return "a0, s5,";
    case 4: return "a0, s6,";
    case 5: return "a0, a1,";
    case 6: return "a0, a2,";
    case 7: return "a0, a3,";
    default: return "";
    }
}

100001,3.DESTREGS,3.RT,3.RS,0:MICROMIPS:16::MOVEP
"movep %s<DESTREGS> r<ERS>, r<ERT>"
*micromips32:
*micromips64:
{
  int rd;
  int re;
  int dest = DESTREGS;

  if (dest == 0 || dest == 1)
    rd = 5;
  else if (dest == 2)
    rd = 6;
  else
    rd = 4;

  if (dest == 0 || dest == 6)
    re = 6;
  else if (dest == 1 || dest == 2 || dest == 7)
    re = 7;
  else if (dest == 3)
    re = 21;
  else if (dest == 4)
    re = 22;
  /* assume dest is 5 */
  else
    re = 5;

  GPR[rd] = GPR[ERS];
  GPR[re] = GPR[ERT];
}


010001,0000,3.RT,3.RS:POOL16C:16::NOT16
"not16 r<TRT>, r<TRS>"
*micromips32:
*micromips64:
{
  do_nor (SD_, 0, TRS, TRT);
}


010001,0011,3.RT,3.RS:POOL16C:16::OR16
"or16 r<TRT>, r<TRS>"
*micromips32:
*micromips64:
{
  do_or (SD_, TRS, TRT, TRT);
}


100010,3.RT_S,3.BASE,4.IMMEDIATE:MICROMIPS:16::SB16
"sb16 r<TRT_S>, <IMMEDIATE>(r<TBASE>)"
*micromips32:
*micromips64:
{
  do_store (SD_, AccessLength_BYTE, GPR[TBASE], IMMEDIATE, GPR[TRT_S]);
}


010001,101100,4.CODE:POOL16C:16::SDBBP16
"sdbbp16 %#lx<CODE>"
*micromips32:
*micromips64:
{
  SignalException (DebugBreakPoint, instruction_0);
}


101010,3.RT_S,3.BASE,4.IMMEDIATE:MICROMIPS:16::SH16
"sh16 r<TRT_S>, <IMM_SHIFT_1BIT>(r<TBASE>)"
*micromips32:
*micromips64:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[TBASE], IMM_SHIFT_1BIT, GPR[TRT_S]);
}


001001,3.RD,3.RT,3.SHIFT,0:POOL16B:16::SLL16
"sll16 r<TRD>, r<TRT>, <SHIFT_DEC>"
*micromips32:
*micromips64:
{
  do_sll (SD_, TRT, TRD, SHIFT_DEC);
}


001001,3.RD,3.RT,3.SHIFT,1:POOL16B:16::SRL16
"srl16 r<TRD>, r<TRT>, <SHIFT_DEC>"
*micromips32:
*micromips64:
{
  do_srl (SD_, TRT, TRD, SHIFT_DEC);
}


000001,3.RD,3.RT,3.RS,1:POOL16A:16::SUBU16
"subu16 r<TRD>, r<TRS>, r<TRT>"
*micromips32:
*micromips64:
{
  do_subu (SD_, TRS, TRT, TRD);
}


111010,3.RT_S,3.BASE,4.IMMEDIATE:MICROMIPS:16::SW16
"sw16 r<TRT_S>, <IMM_SHIFT_2BIT>(r<TBASE>)"
*micromips32:
*micromips64:
{
  do_store (SD_, AccessLength_WORD, GPR[TBASE], IMM_SHIFT_2BIT, GPR[TRT_S]);
}


110010,5.RT,5.IMMEDIATE:MICROMIPS:16::SWSP
"swsp r<RT>, <IMM_SHIFT_2BIT>(sp)"
*micromips32:
*micromips64:
{
  do_store (SD_, AccessLength_WORD, SP, IMM_SHIFT_2BIT, GPR[RT]);
}


010001,0101,2.LWMREGS,4.IMMEDIATE:POOL16C:16::SWM16
"swm16 %s<LWMREGS>, <IMM_SHIFT_2BIT>(sp)"
*micromips32:
*micromips64:
{
  int address = GPR[SPIDX] + IMM_SHIFT_2BIT;
  int reg_offset;

  for (reg_offset = 0; reg_offset <= LWMREGS; reg_offset++)
    do_store (SD_, AccessLength_WORD, address, reg_offset * 4,
	GPR[16 + reg_offset]);

  do_store (SD_, AccessLength_WORD, address, reg_offset * 4, RA);
}


010001,0001,3.RT,3.RS:POOL16C:16::XOR16
"xor16 r<TRT>, r<TRS>"
*micromips32:
*micromips64:
{
  do_xor (SD_, TRS, TRT, TRT);
}


000000,5.RT,5.RS,5.RD,00100,010000:POOL32A:32::ADD
"add r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_add (SD_, RS, RT, RD);
}


000100,5.RT,5.RS,16.IMMEDIATE:MICROMIPS:32::ADDI
"addi r<RT>, r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_addi (SD_, RS, RT, IMMEDIATE);
}


001100,5.RT,5.RS,16.IMMEDIATE:MICROMIPS:32::ADDIU
"li r<RT>, <IMMEDIATE>":RS==0
"addiu r<RT>, r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_addiu (SD_, RS, RT, IMMEDIATE);
}


011110,3.RS,23.IMMEDIATE:MICROMIPS:32::ADDIUPC
"addiupc r<TRS>, <IMM_SHIFT_2BIT>"
*micromips32:
*micromips64:
{
  GPR[TRS] = EXTEND32 ((CIA & ~3) + EXTEND25 (IMM_SHIFT_2BIT));
}


000000,5.RT,5.RS,5.RD,00101,010000:POOL32A:32::ADDU
"addu r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_addu (SD_, RS, RT, RD);
}


000000,5.RT,5.RS,5.RD,01001,010000:POOL32A:32::AND
"and r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_and (SD_, RS, RT, RD);
}


110100,5.RT,5.RS,16.IMMEDIATE:MICROMIPS:32::ANDI
"andi r<RT>, r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_andi (SD_, RS, RT, IMMEDIATE);
}


010000,1110,1.TF,3.CC,00,16.IMMEDIATE:POOL32I:32,f::BC1a
"bc1%s<TF> <IMMEDIATE>":CC == 0
"bc1%s<TF> <CC>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  check_fpu (SD_);
  if (GETFCC(CC) == TF)
    {
      address_word dest = NIA + (EXTEND16 (IMMEDIATE) << 1);
      NIA = delayslot_micromips (SD_, dest, NIA, MICROMIPS_DELAYSLOT_SIZE_ANY);
    }
}


010000,1010,1.TF,3.CC,00,16.IMMEDIATE:POOL32I:32::BC2a
"bc2%s<TF> <CC>, <IMMEDIATE>":CC == 0
"bc2%s<TF> <CC>, <IMMEDIATE>"
*micromips32:
*micromips64:


100101,5.RT,5.RS,16.IMMEDIATE:MICROMIPS:32::BEQ
"b <IMMEDIATE>":RT == 0 && RS == 0
"beq r<RS>, r<RT>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word offset = EXTEND16 (IMMEDIATE) << 1;
  if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
    NIA = delayslot_micromips (SD_, NIA + offset, NIA,
			       MICROMIPS_DELAYSLOT_SIZE_ANY);
}

010000,00010,5.RS,16.IMMEDIATE:POOL32I:32::BGEZ
"bgez r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word offset = EXTEND16 (IMMEDIATE) << 1;
  if ((signed_word) GPR[RS] >= 0)
    NIA = delayslot_micromips (SD_, NIA + offset, NIA,
			       MICROMIPS_DELAYSLOT_SIZE_ANY);
}


010000,00111,5.RS,16.IMMEDIATE:POOL32I:32::BEQZC
"beqzc r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word offset = EXTEND16 (IMMEDIATE) << 1;
  if (GPR[RS] == 0)
    NIA = NIA + offset;
}


010000,00011,5.RS,16.IMMEDIATE:POOL32I:32::BGEZAL
"bal <IMMEDIATE>":RS == 0
"bgezal r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word offset = EXTEND16 (IMMEDIATE) << 1;
  if (RS == 31)
    Unpredictable ();
  RA = (NIA + MICROMIPS_DELAYSLOT_SIZE_32) | ISA_MODE_MICROMIPS;
  if ((signed_word) GPR[RS] >= 0)
    NIA = delayslot_micromips (SD_, NIA + offset, NIA,
			       MICROMIPS_DELAYSLOT_SIZE_32);
}


010000,00110,5.RS,16.IMMEDIATE:POOL32I:32::BGTZ
"bgtz r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word offset = EXTEND16 (IMMEDIATE) << 1;
  if ((signed_word) GPR[RS] > 0)
    NIA = delayslot_micromips (SD_, NIA + offset, NIA,
			       MICROMIPS_DELAYSLOT_SIZE_ANY);
}


010000,10011,5.RS,16.IMMEDIATE:POOL32I:32::BGEZALS
"bal <IMMEDIATE>":RS == 0
"bgezals r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word offset = EXTEND16 (IMMEDIATE) << 1;
  if (RS == 31)
    Unpredictable ();
  RA = (NIA + MICROMIPS_DELAYSLOT_SIZE_16) | ISA_MODE_MICROMIPS;
  if ((signed_word) GPR[RS] >= 0)
    NIA = delayslot_micromips (SD_, NIA + offset, NIA,
			       MICROMIPS_DELAYSLOT_SIZE_16);
}


010000,00100,5.RS,16.IMMEDIATE:POOL32I:32::BLEZ
"blez r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word offset = EXTEND16 (IMMEDIATE) << 1;
  /* NOTE: The branch occurs AFTER the next instruction has been
     executed */
  if ((signed_word) GPR[RS] <= 0)
    NIA = delayslot_micromips (SD_, NIA + offset, NIA,
			       MICROMIPS_DELAYSLOT_SIZE_ANY);
}


010000,00000,5.RS,16.IMMEDIATE:POOL32I:32::BLTZ
"bltz r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word offset = EXTEND16 (IMMEDIATE) << 1;
  if ((signed_word) GPR[RS] < 0)
    NIA = delayslot_micromips (SD_, NIA + offset, NIA,
			       MICROMIPS_DELAYSLOT_SIZE_ANY);
}


010000,00001,5.RS,16.IMMEDIATE:POOL32I:32::BLTZAL
"bltzal r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word offset = EXTEND16 (IMMEDIATE) << 1;
  if (RS == 31)
    Unpredictable ();
  RA = (NIA + MICROMIPS_DELAYSLOT_SIZE_32) | ISA_MODE_MICROMIPS;
  /* NOTE: The branch occurs AFTER the next instruction has been
     executed */
  if ((signed_word) GPR[RS] < 0)
    NIA = delayslot_micromips (SD_, NIA + offset, NIA,
			       MICROMIPS_DELAYSLOT_SIZE_32);
}

010000,10001,5.RS,16.IMMEDIATE:POOL32I:32::BLTZALS
"bltzals r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word offset = EXTEND16 (IMMEDIATE) << 1;
  if (RS == 31)
    Unpredictable ();
  RA = (NIA + MICROMIPS_DELAYSLOT_SIZE_16) | ISA_MODE_MICROMIPS;
  if ((signed_word) GPR[RS] < 0)
    NIA = delayslot_micromips (SD_, NIA + offset, NIA,
			       MICROMIPS_DELAYSLOT_SIZE_16);
}


101101,5.RT,5.RS,16.IMMEDIATE:MICROMIPS:32::BNE
"bne r<RS>, r<RT>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word offset = EXTEND16 (IMMEDIATE) << 1;
  if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
    NIA = delayslot_micromips (SD_, NIA + offset, NIA,
			       MICROMIPS_DELAYSLOT_SIZE_ANY);
}


010000,00101,5.RS,16.IMMEDIATE:POOL32I:32::BNEZC
"bnezc r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  address_word offset = EXTEND16 (IMMEDIATE) << 1;
  if ((signed_word) GPR[RS] != 0)
    NIA = NIA + offset;
}


000000,20.CODE,000111:POOL32A:32::BREAK
"break %#lx<CODE>"
*micromips32:
*micromips64:
{
  do_break (SD_, instruction_0);
}


001000,5.OP,5.BASE,0110,12.IMMEDIATE:POOL32B:32::CACHE
"cache <OP>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  address_word base = GPR[BASE];
  address_word offset = EXTEND12 (IMMEDIATE);
  address_word vaddr = loadstore_ea (SD_, base, offset);
  address_word paddr = vaddr;
  CacheOp (OP, vaddr, paddr, instruction_0);
}


011000,5.OP,5.BASE,1010011,9.IMMEDIATE:POOL32C:32::CACHEE
"cachee <OP>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


010101,5.RT,5.FS,0001000000,111011:POOL32F:32,f::CFC1
"cfc1 r<RT>, f<FS>"
*micromips32:
*micromips64:
{
  do_cfc1 (SD_, RT, FS);
}


000000,5.RT,5.IMPL,1100110100,111100:POOL32A:32::CFC2
"cfc2 r<RT>, <IMPL>"
*micromips32:
*micromips64:


000000,5.RT,5.RS,0100101100,111100:POOL32A:32::CLO
"clo r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  do_clo (SD_, RT, RS);
}


000000,5.RT,5.RS,0101101100,111100:POOL32A:32::CLZ
"clz r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  do_clz (SD_, RT, RS);
}


000000,23.COFUN,010:POOL32A:32::COP2
"cop2 <COFUN>"
*micromips32:
*micromips64:


010101,5.RT,5.FS,0001100000,111011:POOL32F:32,f::CTC1
"ctc1 r<RT>, f<FS>"
*micromips32:
*micromips64:
{
  do_ctc1 (SD_, RT, FS);
}


000000,5.RT,5.IMPL,1101110100,111100:POOL32A:32::CTC2
"ctc2 r<RT>, <IMPL>"
*micromips32:
*micromips64:


000000,00000000001110001101,111100:POOL32A:32::DERET
"deret"
*micromips32:
*micromips64:


000000,00000,5.RS,0100011101,111100:POOL32A:32::DI
"di":RS == 0
"di r<RS>"
*micromips32:
*micromips64:
{
  do_di (SD_, RS);
}

000000,5.RT,5.RS,1010101100,111100:POOL32A:32::DIV
"div r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_div (SD_, RS, RT);
}


000000,5.RT,5.RS,1011101100,111100:POOL32A:32::DIVU
"divu r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_divu (SD_, RS, RT);
}


000000,00000000000001100000,000000:POOL32A:32::EHB
"ehb"
*micromips32:
*micromips64:


000000,00000,5.RS,0101011101,111100:POOL32A:32::EI
"ei":RS == 0
"ei r<RS>"
*micromips32:
*micromips64:
{
  do_ei (SD_, RS);
}

000000,00000000001111001101,111100:POOL32A:32::ERET
"eret"
*micromips32:
*micromips64:
{
  if (SR & status_ERL)
    {
      /* Oops, not yet available */
      sim_io_printf (SD, "Warning: ERET when SR[ERL] set not supported");
      NIA = EPC;
      SR &= ~status_ERL;
    }
  else
    {
      NIA = EPC;
      SR &= ~status_EXL;
    }
}


000000,5.RT,5.RS,5.MSBD,5.LSB,101100:POOL32A:32::EXT
"ext r<RT>, r<RS>, <LSB>, <MSBD+1>"
*micromips32:
*micromips64:
{
  do_ext (SD_, RT, RS, LSB, MSBD);
}


000000,5.RT,5.RS,5.MSBD,5.LSB,001100:POOL32A:32::INS
"ins r<RT>, r<RS>, <LSB>, <MSBD-LSB+1>"
*micromips32:
*micromips64:
{
  do_ins (SD_, RT, RS, LSB, MSBD);
}


110101,26.IMMEDIATE:MICROMIPS:32::J
"j <IMM_SHIFT_1BIT>"
*micromips32:
*micromips64:
{
  address_word region = (NIA & MASK (63, 27));
  NIA = delayslot_micromips (SD_, region | (IMM_SHIFT_1BIT), NIA,
			     MICROMIPS_DELAYSLOT_SIZE_ANY);
}


111101,26.IMMEDIATE:MICROMIPS:32::JAL
"jal <IMM_SHIFT_1BIT>"
*micromips32:
*micromips64:
{
  /* NOTE: The region used is that of the delay slot and NOT the
     current instruction */
  address_word region = (NIA & MASK (63, 27));
  NIA = do_micromips_jal (SD_, (region | (IMM_SHIFT_1BIT)), NIA,
			  MICROMIPS_DELAYSLOT_SIZE_32);
}


011101,26.IMMEDIATE:MICROMIPS:32::JALS
"jals <IMM_SHIFT_1BIT>"
*micromips32:
*micromips64:
{
  address_word region = (NIA & MASK (63, 27));
  NIA = do_micromips_jal (SD_, (region | (IMM_SHIFT_1BIT)), NIA,
			  MICROMIPS_DELAYSLOT_SIZE_16);
}

000000,5.RT!0,5.RS,0000111100,111100:POOL32A:32::JALR
"jalr r<RS>":RT == 31
"jalr r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  if (RS == RT)
    Unpredictable ();
  NIA = do_micromips_jalr (SD_, RT, RS, NIA, MICROMIPS_DELAYSLOT_SIZE_32);
}

000000,5.RT,5.RS,0100111100,111100:POOL32A:32::JALRS
"jalrs r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  if (RS == RT)
    Unpredictable ();
  NIA = do_micromips_jalr (SD_, RT, RS, NIA, MICROMIPS_DELAYSLOT_SIZE_16);
}


111100,26.IMMEDIATE:MICROMIPS:32::JALX
"jalx <IMM_SHIFT_2BIT>"
*micromips32:
*micromips64:
{
  struct mips_sim_state *state = MIPS_SIM_STATE (SD);
  address_word region = (NIA & MASK (63, 26));
  NIA = do_micromips_jal (SD_, (region | (IMM_SHIFT_2BIT)) | ISA_MODE_MIPS32,
			  NIA, MICROMIPS_DELAYSLOT_SIZE_32);
  state->isa_mode = ISA_MODE_MIPS32;
}

000000,00000,5.RS,0000111100,111100:POOL32A:32::JR
"jr r<RS>"
*micromips32:
*micromips64:
{
  NIA = process_isa_mode (SD_,
			  delayslot_micromips (SD_, GPR[RS], NIA,
					       MICROMIPS_DELAYSLOT_SIZE_32));
}


000000,5.RT,5.RS,0001111100,111100:POOL32A:32::JALR.HB
"jalr.hb r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  if (RS == RT)
    Unpredictable ();
  NIA = do_micromips_jalr (SD_, RT, RS, NIA, MICROMIPS_DELAYSLOT_SIZE_32);
}


000000,5.RT,5.RS,0101111100,111100:POOL32A:32::JALRS.HB
"jalrs.hb r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  if (RS == RT)
    Unpredictable ();
  NIA = do_micromips_jalr (SD_, RT, RS, NIA, MICROMIPS_DELAYSLOT_SIZE_16);
}


000000,00000,5.RS,0111111100,111100:POOL32A:32::JR.HB
"jr.hb r<RS>"
*micromips32:
*micromips64:
{
  NIA = process_isa_mode (SD_,
			  delayslot_micromips (SD_, GPR[RS], NIA,
					       MICROMIPS_DELAYSLOT_SIZE_32));
}


000111,5.RT,5.BASE,16.IMMEDIATE:MICROMIPS:32::LB
"lb r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_lb (SD_, RT, IMMEDIATE, BASE);
}


011000,5.RT,5.BASE,0110100,9.IMMEDIATE:POOL32C:32::LBE
"lbe r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


000101,5.RT,5.BASE,16.IMMEDIATE:MICROMIPS:32::LBU
"lbu r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_lbu (SD_, RT, IMMEDIATE, BASE);
}


011000,5.RT,5.BASE,0110000,9.IMMEDIATE:POOL32C:32::LBUE
"lbue r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


101111,5.FT,5.BASE,16.IMMEDIATE:MICROMIPS:32,f::LDC1a
"ldc1 f<FT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
{
  check_fpu (SD_);
  COP_LD (1, FT, do_load_double (SD_, GPR[BASE], EXTEND16 (IMMEDIATE)));
}


101111,5.FT,5.BASE,16.IMMEDIATE:MICROMIPS:32,f::LDC1b
"ldc1 f<FT>, <IMMEDIATE>(r<BASE>)"
*micromips64:
{
  check_fpu (SD_);
  COP_LD (1, FT, do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE],
			  EXTEND16 (IMMEDIATE)));
}


001000,5.RT,5.BASE,0010,12.IMMEDIATE:POOL32B:32::LDC2
"ldc2 r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


001111,5.RT,5.BASE,16.IMMEDIATE:MICROMIPS:32::LH
"lh r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_lh (SD_, RT, IMMEDIATE, BASE);
}


011000,5.RT,5.BASE,0110101,9.IMMEDIATE:POOL32C:32::LHE
"lhe r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


001101,5.RT,5.BASE,16.IMMEDIATE:MICROMIPS:32::LHU
"lhu r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_lhu (SD_, RT, IMMEDIATE, BASE);
}


011000,5.RT,5.BASE,0110001,9.IMMEDIATE:POOL32C:32::LHUE
"lhue r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


011000,5.RT,5.BASE,0011,12.IMMEDIATE:POOL32C:32::LL
"ll r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_ll (SD_, RT, EXTEND12 (IMMEDIATE), BASE);
}


011000,5.RT,5.BASE,0110110,9.IMMEDIATE:POOL32C:32::LLE
"lle r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


010000,01101,5.RS,16.IMMEDIATE:POOL32I:32::LUI
"lui r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_lui (SD_, RS, IMMEDIATE);
}


010101,5.INDEX,5.BASE,5.FD,00101,001000:POOL32F:32,f::LUXC1
"luxc1 f<FD>, r<INDEX>(r<BASE>)"
*micromips32:
{
  do_luxc1_32 (SD_, FD, INDEX, BASE);
}


010101,5.INDEX,5.BASE,5.FD,00101,001000:POOL32F:64,f::LUXC1
"luxc1 f<FD>, r<INDEX>(r<BASE>)"
*micromips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  do_luxc1_64 (SD_, FD, INDEX, BASE);
}


111111,5.RT,5.BASE,16.IMMEDIATE:MICROMIPS:32::LW
"lw r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_lw (SD_, RT, IMMEDIATE, BASE);
}


100111,5.FT,5.BASE,16.IMMEDIATE:MICROMIPS:32,f::LWC1
"lwc1 f<FT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_lwc1 (SD_, FT, IMMEDIATE, BASE);
}


001000,5.RT,5.BASE,0000,12.IMMEDIATE:POOL32B:32::LWC2
"lwc2 r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


011000,5.RT,5.BASE,0110111,9.IMMEDIATE:POOL32C:32::LWE
"lwe r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


011000,5.RT,5.BASE,0110011,9.IMMEDIATE:POOL32C:32::LWEE
"lwee r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


011000,5.RT,5.BASE,0000,12.IMMEDIATE:POOL32C:32::LWL
"lwl r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_lwl (SD_, RT, EXTEND12 (IMMEDIATE), BASE);
}


011000,5.RT,5.BASE,0110010,9.IMMEDIATE:POOL32C:32::LWLE
"lwle r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:

:%s::::LWM32REGS:int lwmregs
*micromips32:
*micromips64:
{
  if (lwmregs & 0x10)
    {
      switch (lwmregs & 0xf)
        {
        case 0:
          return "ra";
        case 1:
          return "s0, ra";
        case 2:
          return "s0, s1, ra";
        case 3:
          return "s0, s1, s2, ra";
        case 4:
          return "s0, s1, s2, s3, ra";
        case 5:
          return "s0, s1, s2, s3, s4, ra";
        case 6:
          return "s0, s1, s2, s3, s4, s5, ra";
        case 7:
          return "s0, s1, s2, s3, s4, s5, s6, ra";
        case 8:
          return "s0, s1, s2, s3, s4, s5, s6, s7, ra";
        case 9:
          return "s0, s1, s2, s3, s4, s5, s6, s7, s8, ra";
        default:
          return "";
        }
    }
  else
    {
      switch (lwmregs & 0xf)
        {
        case 1:
          return "s0";
        case 2:
          return "s0, s1";
        case 3:
          return "s0, s1, s2";
        case 4:
          return "s0, s1, s2, s3";
        case 5:
          return "s0, s1, s2, s3, s4";
        case 6:
          return "s0, s1, s2, s3, s4, s5";
        case 7:
          return "s0, s1, s2, s3, s4, s5, s6";
        case 8:
          return "s0, s1, s2, s3, s4, s5, s6, s7";
        case 9:
          return "s0, s1, s2, s3, s4, s5, s6, s7, s8";
        default:
          return "";
        }
    }
}

001000,5.LWM32REGS,5.BASE,0101,12.IMMEDIATE:POOL32B:32::LWM32
"lwm32 %s<LWM32REGS>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  int address_base = GPR[BASE] + EXTEND12 (IMMEDIATE);
  int reg_offset;
  for (reg_offset = 0; reg_offset < (LWM32REGS & 0xf); reg_offset++)
    {
      int dst = (reg_offset == 8) ? 30 : 16 + reg_offset;
      GPR[dst] = EXTEND32 (do_load (SD_, AccessLength_WORD, address_base,
				    4 * reg_offset));
    }

  if (LWM32REGS & 0x10)
    RA = EXTEND32 (do_load (SD_, AccessLength_WORD, address_base,
			    4 * reg_offset));
}


001000,5.RD,5.BASE,0001,12.IMMEDIATE:POOL32B:32::LWP
"lwp r<RD>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  if (BASE == RD || RD == 31)
    Unpredictable ();
  else
    {
      do_lw (SD_, RD, EXTEND12 (IMMEDIATE), BASE);
      do_lw (SD_, RD + 1, EXTEND12 (IMMEDIATE) + 4, BASE);
    }
}


011000,5.RT,5.BASE,0001,12.IMMEDIATE:POOL32C:32::LWR
"lwr r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_lwr (SD_, RT, EXTEND12 (IMMEDIATE), BASE);
}


011000,5.RT,5.BASE,1110,12.IMMEDIATE:POOL32C:32::LWU
"lwu r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_lwu (SD_, RT, IMMEDIATE, BASE, instruction_0);
}


010101,5.INDEX,5.BASE,5.FD,00001,001000:POOL32F:32,f::LWXC1
"lwxc1 f<FD>, <INDEX>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_lwxc1 (SD_, FD, INDEX, BASE, instruction_0);
}


000000,5.INDEX,5.BASE,5.RD,00100,011000:POOL32A:32::LWXS
"lwxs r<RD>, r<INDEX>(r<BASE>)"
*micromips32:
*micromips64:
{
  GPR[RD] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[BASE],
			       GPR[INDEX] * 4));
}


000000,5.RT,5.RS,1100101100,111100:POOL32A:32::MADD
"madd r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_madd (SD_, RS, RT);
}


000000,5.RT,5.RS,1101101100,111100:POOL32A:32::MADDU
"maddu r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_maddu (SD_, RS, RT);
}


000000,5.RT,5.RS,00,3.SEL,00011,111100:POOL32A:32::MFC0
"mfc0 r<RS>, r<RT>": SEL == 0
"mfc0 r<RS>, r<RT>, <SEL>"
*micromips32:
*micromips64:
{
  DecodeCoproc (instruction_0, 0, cp0_mfc0, RT, RS, SEL);
}


010101,5.RT,5.FS,0010000000,111011:POOL32F:32,f::MFC1
"mfc1 r<RT>, f<FS>"
*micromips32:
*micromips64:
{
  do_mfc1b (SD_, RT, FS);
}


000000,5.RT,5.IMPL,0100110100,111100:POOL32A:32::MFC2
"mfc2 r<RT>, <IMPL>"
*micromips32:
*micromips64:


010101,5.RT,5.FS,0011000000,111011:POOL32F:32,f::MFHC1
"mfhc1 r<RT>, f<FS>"
*micromips32:
*micromips64:
{
  do_mfhc1 (SD_, RT, FS);
}


000000,5.RT,5.IMPL,1000110100,111100:POOL32A:32::MFHC2
"mfhc2 r<RT>, <IMPL>"
*micromips32:
*micromips64:


000000,00000,5.RS,0000110101,111100:POOL32A:32::MFHI
"mfhi r<RS>"
*micromips32:
*micromips64:
{
  do_mfhi (SD_, RS);
}


000000,00000,5.RS,0001110101,111100:POOL32A:32::MFLO
"mflo r<RS>"
*micromips32:
*micromips64:
{
  do_mflo (SD_, RS);
}


// MOVF
// MOVT
010101,5.RT,5.RS,3.CC,0,1.TF,00101,111011:POOL32F:32::MOVtf
"mov%s<TF> r<RT>, r<RS>, CC"
*micromips32:
*micromips64:
{
  do_movtf (SD_, TF, RT, RS, CC);
}


000000,5.RT,5.RS,5.RD,00000,011000:POOL32A:32::MOVN
"movn r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_movn (SD_, RD, RS, RT);
}


000000,5.RT,5.RS,5.RD,00001,011000:POOL32A:32::MOVZ
"movz r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_movz (SD_, RD, RS, RT);
}


000000,5.RT,5.RS,1110101100,111100:POOL32A:32::MSUB
"msub r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_msub (SD_, RS, RT);
}


000000,5.RT,5.RS,1111101100,111100:POOL32A:32::MSUBU
"msubu r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_msubu (SD_, RS, RT);
}


000000,5.RT,5.RS,00,3.SEL,01011,111100:POOL32A:32::MTC0
"mtc0 r<RS>, r<RT>": SEL == 0
"mtc0 r<RS>, r<RT>, <SEL>"
*micromips32:
*micromips64:
{
  DecodeCoproc (instruction_0, 0, cp0_mtc0, RT, RS, SEL);
}


010101,5.RT,5.FS,0010100000,111011:POOL32F:32,f::MTC1
"mtc1 r<RT>, f<FS>"
*micromips32:
*micromips64:
{
  do_mtc1b (SD_, RT, FS);
}


000000,5.RT,5.IMPL,0101110100,111100:POOL32A:32::MTC2
"mtc2 r<RT>, <IMPL>"
*micromips32:
*micromips64:


010101,5.RT,5.FS,0011100000,111011:POOL32F:32,f::MTHC1
"mthc1 r<RT>, f<FS>"
*micromips32:
*micromips64:
{
  do_mthc1 (SD_, RT, FS);
}


000000,5.RT,5.IMPL,1001110100,111100:POOL32A:32::MTHC2
"mthc2 r<RT>, <IMPL>"
*micromips32:
*micromips64:


000000,00000,5.RS,0010110101,111100:POOL32A:32::MTHI
"mthi r<RS>"
*micromips32:
*micromips64:
{
  do_mthi (SD_, RS);
}


000000,00000,5.RS,0011110101,111100:POOL32A:32::MTLO
"mtlo r<RS>"
*micromips32:
*micromips64:
{
  do_mtlo (SD_, RS);
}


000000,5.RT,5.RS,5.RD,01000,010000:POOL32A:32::MUL
"mul r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_mul (SD_, RD, RS, RT);
}


000000,5.RT,5.RS,1000101100,111100:POOL32A:32::MULT
"mult r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_mult (SD_, RS, RT, 0);
}


000000,5.RT,5.RS,1001101100,111100:POOL32A:32::MULTU
"multu r<RS> r<RT>"
*micromips32:
*micromips64:
{
  do_multu (SD_, RS, RT, 0);
}


000000,00000000000000000000,000000:POOL32A:32::NOP
"nop"
*micromips32:
*micromips64:
{
}


000000,5.RT,5.RS,5.RD,01011,010000:POOL32A:32::NOR
"nor r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_nor (SD_, RS, RT, RD);
}


000000,5.RT,5.RS,5.RD,01010,010000:POOL32A:32::OR
"or r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_or (SD_, RS, RT, RD);
}


010100,5.RT,5.RS,16.IMMEDIATE:MICROMIPS:32::ORI
"ori r<RT>, r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_ori (SD_, RS, RT, IMMEDIATE);
}


000000,00000000000010100000,000000:POOL32A:32::PAUSE
"pause"
*micromips32:
*micromips64:


011000,5.HINT,5.BASE,0010,12.IMMEDIATE:POOL32C:32::PREF
"pref <HINT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_pref (SD_, HINT, EXTEND12 (IMMEDIATE), BASE);
}


011000,5.HINT,5.BASE,1010010,9.IMMEDIATE:POOL32C:32::PREFE
"prefe <HINT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


010101,5.INDEX,5.BASE,5.HINT,00110,100000:POOL32F:32::PREFX
"prefx <HINT>, r<INDEX>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_prefx (SD_, HINT, INDEX, BASE);
}

000000,5.RT,5.RS,0110101100,111100:POOL32A:32::RDHWR
"rdhwr r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_rdhwr (SD_, RT, RS);
}

000000,5.RT,5.RS,1110000101,111100:POOL32A:32::RDPGPR
"rdpgpr r<RS>, r<RT>"
*micromips32:
*micromips64:


000000,5.RT,5.RS,5.SHIFT,00011,000000:POOL32A:32::ROTR
"rotr r<RT>, r<RS>, <SHIFT>"
*micromips32:
*micromips64:
{
  GPR[RT] = do_ror (SD_, GPR[RS], SHIFT);
}


000000,5.RT,5.RS,5.RD,00011,010000:POOL32A:32::ROTRV
"rotrv r<RD>, r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  GPR[RD] = do_ror (SD_, GPR[RT], GPR[RS]);
}


000110,5.RT,5.BASE,16.IMMEDIATE:MICROMIPS:32::SB
"sb r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_store (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (IMMEDIATE), GPR[RT]);
}


011000,5.RT,5.BASE,1010101,9.IMMEDIATE:POOL32C:32::SBE
"sbe r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


011000,5.RT,5.BASE,1011,12.IMMEDIATE:POOL32C:32::SC
"sc r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_sc (SD_, RT, EXTEND12 (IMMEDIATE), BASE, instruction_0, 1);
}


011000,5.RT,5.BASE,1010110,9.IMMEDIATE:POOL32C:32::SCE
"sce r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


000000,10.CODE,1101101101,111100:POOL32A:32::SDBBP
"sdbbp %#lx<CODE>"
*micromips32:
*micromips64:
{
  SignalException (DebugBreakPoint, instruction_0);
}


101110,5.FT,5.BASE,16.IMMEDIATE:MICROMIPS:32,f::SDC1a
"sdc1 f<FT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
{
  do_sdc1 (SD_, FT, IMMEDIATE, BASE);
}


101110,5.FT,5.BASE,16.IMMEDIATE:MICROMIPS:32,f::SDC1b
"sdc1 f<FT>, <IMMEDIATE>(r<BASE>)"
*micromips64:
{
  check_fpu (SD_);
  do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (IMMEDIATE),
	    COP_SD (1, FT));
}


001000,5.RT,5.BASE,1010,12.IMMEDIATE:MICROMIPS:32::SDC2
"sdc2 r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


000000,5.RT,5.RS,0010101100,111100:POOL32A:32::SEB
"seb r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  do_seb (SD_, RT, RS);
}


000000,5.RT,5.RS,0011101100,111100:POOL32A:32::SEH
"seh r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  do_seh (SD_, RT, RS);
}


001110,5.RT,5.BASE,16.IMMEDIATE:MICROMIPS:32::SH
"sh r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (IMMEDIATE),
	    GPR[RT]);
}


011000,5.RT,5.BASE,1010100,9.IMMEDIATE:POOL32C:32::SHE
"she r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


000000,5.RT!0,5.RS!0,5.SHIFT,00000,000000:POOL32A:32::SLL
"sll r<RT>, r<RS>, <SHIFT>"
*micromips32:
*micromips64:
{
  do_sll (SD_, RS, RT, SHIFT);
}


000000,5.RT,5.RS,5.RD,00000,010000:POOL32A:32::SLLV
"sllv r<RD>, r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  do_sllv (SD_, RS, RT, RD);
}


000000,5.RT,5.RS,5.RD,01101,010000:POOL32A:32::SLT
"slt r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_slt (SD_, RS, RT, RD);
}


100100,5.RT,5.RS,16.IMMEDIATE:MICROMIPS:32::SLTI
"slti r<RT>, r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_slti (SD_, RS, RT, IMMEDIATE);
}


101100,5.RT,5.RS,16.IMMEDIATE:MICROMIPS:32::SLTIU
"sltiu r<RT>, r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_sltiu (SD_, RS, RT, IMMEDIATE);
}


000000,5.RT,5.RS,5.RD,01110,010000:POOL32A:32::SLTU
"sltu r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_sltu (SD_, RS, RT, RD);
}


000000,5.RT,5.RS,5.SHIFT,00010,000000:POOL32A:32::SRA
"sra r<RT>, r<RS>, <SHIFT>"
*micromips32:
*micromips64:
{
  do_sra (SD_, RS, RT, SHIFT);
}


000000,5.RT,5.RS,5.RD,00010,010000:POOL32A:32::SRAV
"srav r<RD>, r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  do_srav (SD_, RS, RT, RD);
}


000000,5.RT,5.RS,5.SHIFT,00001,000000:POOL32A:32::SRL
"srl r<RT>, r<RS>, <SHIFT>"
*micromips32:
*micromips64:
{
  do_srl (SD_, RS, RT, SHIFT);
}


000000,5.RT,5.RS,5.RD,00001,010000:POOL32A:32::SRLV
"srlv r<RD>, r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  do_srlv (SD_, RS, RT, RD);
}


000000,00000000000000100000,000000:POOL32A:32::SSNOP
"ssnop"
*micromips32:
*micromips64:
{
}


000000,5.RT,5.RS,5.RD,00110,010000:POOL32A:32::SUB
"sub r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_sub (SD_, RD, RS, RT);
}


000000,5.RT,5.RS,5.RD,00111,010000:POOL32A:32::SUBU
"subu r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_subu (SD_, RS, RT, RD);
}


010101,5.INDEX,5.BASE,5.FD,00110,001000:POOL32F:32,f::SUXC1
"suxc1 f<FD>, r<INDEX>(r<BASE>)"
*micromips32:
{
  do_suxc1_32 (SD_, FD, INDEX, BASE);
}


010101,5.INDEX,5.BASE,5.FD,00110,001000:POOL32F:64,f::SUXC1
"suxc1 f<FD>, r<INDEX>(r<BASE>)"
*micromips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  do_suxc1_64 (SD_, FD, INDEX, BASE);
}

111110,5.RT,5.BASE,16.IMMEDIATE:MICROMIPS:32::SW
"sw r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_store (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (IMMEDIATE), GPR[RT]);
}


100110,5.FT,5.BASE,16.IMMEDIATE:MICROMIPS:32,f::SWC1
"swc1 f<FT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_swc1 (SD_, FT, IMMEDIATE, BASE, instruction_0);
}


001000,5.RT,5.BASE,1000,12.IMMEDIATE:POOL32B:32::SWC2
"swc2 r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


011000,5.RT,5.BASE,1010111,9.IMMEDIATE:POOL32C:32::SWE
"swe r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


011000,5.RT,5.BASE,1000,12.IMMEDIATE:POOL32C:32::SWL
"swl r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_store_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND12 (IMMEDIATE),
		 GPR[RT]);
}


011000,5.RT,5.BASE,1010000,9.IMMEDIATE:POOL32C:32::SWLE
"swle r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


001000,5.LWM32REGS,5.BASE,1101,12.IMMEDIATE:POOL32B:32::SWM32
"swm32 %s<LWM32REGS>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  int address_base = GPR[BASE] + EXTEND12 (IMMEDIATE);
  int reg_offset;
  for (reg_offset = 0; reg_offset < (LWM32REGS & 0xf); reg_offset++)
    {
      int src = (reg_offset == 8) ? 30 : 16 + reg_offset;
      do_store (SD_, AccessLength_WORD, address_base, 4 * reg_offset,
		GPR[src]);
    }

  if (LWM32REGS & 0x10)
    do_store (SD_, AccessLength_WORD, address_base, 4 * reg_offset, RA);
}


001000,5.RS1,5.BASE,1001,12.IMMEDIATE:POOL32B:32::SWP
"swp r<RS1>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  if (RS1 == 31)
    Unpredictable ();
  else
    {
      do_sw (SD_, RS1, EXTEND12 (IMMEDIATE), BASE);
      do_sw (SD_, RS1 + 1, EXTEND12 (IMMEDIATE) + 4, BASE);
    }
}


011000,5.RT,5.BASE,1001,12.IMMEDIATE:POOL32C:32::SWR
"swr r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_store_right (SD_, AccessLength_WORD, GPR[BASE], EXTEND12 (IMMEDIATE),
		  GPR[RT]);
}


011000,5.RT,5.BASE,1010001,9.IMMEDIATE:POOL32C:32::SWRE
"swre r<RT>, <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:


010101,5.INDEX,5.BASE,5.FD,00010,001000:POOL32F:32,f::SWXC1
"swxc1 f<FD>, r<INDEX>(r<BASE>)"
*micromips32:
*micromips64:
{
  do_swxc1 (SD_, FD, INDEX, BASE, instruction_0);
}


000000,00000,5.STYPE,0110101101,111100:POOL32A:32::SYNC
"sync <STYPE>"
*micromips32:
*micromips64:
{
  SyncOperation (STYPE);
}


010000,10000,5.BASE,16.IMMEDIATE:POOL32I:32::SYNCI
"synci <IMMEDIATE>(r<BASE>)"
*micromips32:
*micromips64:
{
}

000000,10.CODE,1000101101,111100:POOL32A:32::SYSCALL
"syscall %#lx<CODE>"
*micromips32:
*micromips64:
{
  SignalException (SystemCall, instruction_0);
}


000000,5.RT,5.RS,4.CODE,000000,111100:POOL32A:32::TEQ
"teq r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_teq (SD_, RS, RT, instruction_0);
}


010000,01110,5.RS,16.IMMEDIATE:POOL32I:32::TEQI
"teqi r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_teqi (SD_, RS, IMMEDIATE, instruction_0);
}


000000,5.RT,5.RS,4.CODE,001000,111100:POOL32A:32::TGE
"tge r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_tge (SD_, RS, RT, instruction_0);
}


010000,01001,5.RS,16.IMMEDIATE:POOL32I:32::TGEI
"tgei r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_tgei (SD_, RS, IMMEDIATE, instruction_0);
}


010000,01011,5.RS,16.IMMEDIATE:POOL32I:32::TGEIU
"tgeiu r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_tgeiu (SD_, RS, IMMEDIATE, instruction_0);
}


000000,5.RT,5.RS,4.CODE,010000,111100:POOL32A:32::TGEU
"tgeu r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_tgeu (SD_, RS, RT, instruction_0);
}


000000,00000000000000001101,111100:POOL32A:32::TLBP
"tlbp"
*micromips32:
*micromips64:


000000,00000000000001001101,111100:POOL32A:32::TLBR
"tlbr"
*micromips32:
*micromips64:


000000,00000000000010001101,111100:POOL32A:32::TLBWI
"tlbwi"
*micromips32:
*micromips64:


000000,00000000000011001101,111100:POOL32A:32::TLBWR
"tlbwr"
*micromips32:
*micromips64:


000000,5.RT,5.RS,4.CODE,100000,111100:POOL32A:32::TLT
"tlt r<RS>, r<RT>, %#lx<CODE>"
*micromips32:
*micromips64:
{
  do_tlt (SD_, RS, RT, instruction_0);
}


010000,01000,5.RS,16.IMMEDIATE:POOL32I:32::TLTI
"tlti r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_tlti (SD_, RS, IMMEDIATE, instruction_0);
}


010000,01010,5.RS,16.IMMEDIATE:POOL32I:32::TLTIU
"tltiu r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_tltiu (SD_, RS, IMMEDIATE, instruction_0);
}


000000,5.RT,5.RS,4.CODE,101000,111100:POOL32A:32::TLTU
"tltu r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_tltu (SD_, RS, RT, instruction_0);
}


000000,5.RT,5.RS,4.CODE,110000,111100:POOL32A:32::TNE
"tne r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_tne (SD_, RS, RT, instruction_0);
}


010000,01100,5.RS,16.IMMEDIATE:POOL32I:32::TNEI
"tnei r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_tnei (SD_, RS, IMMEDIATE, instruction_0);
}


000000,10.CODE,1001001101,111100:POOL32A:32::WAIT
"wait"
*micromips32:
*micromips64:


000000,5.RT,5.RS,1111000101,111100:POOL32A:32::WRPGPR
"wrpgpr r<RS>, r<RT>"
*micromips32:
*micromips64:


000000,5.RT,5.RS,0111101100,111100:POOL32A:32::WSBH
"wsbh r<RT>, r<RS>"
*micromips32:
*micromips64:
{
  do_wsbh (SD_, RT, RS);
}


000000,5.RT,5.RS,5.RD,01100,010000:POOL32A:32::XOR
"xor r<RD>, r<RS>, r<RT>"
*micromips32:
*micromips64:
{
  do_xor (SD_, RS, RT, RD);
}


011100,5.RT,5.RS,16.IMMEDIATE:MICROMIPS:32::XORI
"xori r<RT>, r<RS>, <IMMEDIATE>"
*micromips32:
*micromips64:
{
  do_xori (SD_, RS, RT, IMMEDIATE);
}


:%s::::FMT_MICROMIPS:int fmt
*micromips32:
*micromips64:
{
  switch (fmt)
    {
    case 0: return "s";
    case 1: return "d";
    case 2: return "ps";
    default: return "?";
    }
}


:%s::::FMT_MICROMIPS_CVT_D:int fmt
*micromips32:
*micromips64:
{
  switch (fmt)
    {
    case 0: return "s";
    case 1: return "w";
    case 2: return "l";
    default: return "?";
    }
}


:%s::::FMT_MICROMIPS_CVT_S:int fmt
*micromips32:
*micromips64:
{
  switch (fmt)
    {
    case 0: return "d";
    case 1: return "w";
    case 2: return "l";
    default: return "?";
    }
}


010101,5.FT,5.FS,0,2.FMT_MICROMIPS!3,0001101,111011:POOL32F:32,f::ABS.fmt
"abs.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_abs_fmt (SD_, convert_fmt_micromips (SD_, FMT_MICROMIPS), FT, FS,
	      instruction_0);
}


010101,5.FT,5.FS,5.FD,0,2.FMT_MICROMIPS!3,00,110000:POOL32F:32,f::ADD.fmt
"add.%s<FMT_MICROMIPS> f<FD>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_add_fmt (SD_, convert_fmt_micromips (SD_, FMT_MICROMIPS), FD, FS, FT,
	      instruction_0);
}


010101,5.FT,5.FS,5.FD,5.RS,011001:POOL32F:32,f::ALNV.PS
"alnv.ps f<FD>, f<FS>, f<FT>, r<RS>"
*micromips32:
*micromips64:
{
  do_alnv_ps (SD_, FD, FS, FT, RS, instruction_0);
}


010101,5.FT,5.FS,3.CC,0,2.FMT_MICROMIPS!3,4.COND,111100:POOL32F:32,f::C.cond.fmt
"c.%s<COND>.%s<FMT_MICROMIPS> f<FS>, f<FT>":CC == 0
"c.%s<COND>.%s<FMT_MICROMIPS> <CC>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_c_cond_fmt (SD_, COND, convert_fmt_micromips (SD_, FMT_MICROMIPS), CC,
		 FS, FT, instruction_0);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,01001100,111011:POOL32F:32,f::CEIL.L.fmt
"ceil.l.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_ceil_fmt (SD_, fmt_long, FMT_MICROMIPS, FT, FS, instruction_0);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,01101100,111011:POOL32F:32,f::CEIL.W.fmt
"ceil.w.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_ceil_fmt (SD_, fmt_word, FMT_MICROMIPS, FT, FS, instruction_0);
}


010101,5.FT,5.FS,0,2.FMT_MICROMIPS_CVT_D!3,1001101,111011:POOL32F:32,f::CVT.D.fmt
"cvt.d.%s<FMT_MICROMIPS_CVT_D> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_cvt_d_fmt (SD_, convert_fmt_micromips_cvt_d (SD_, FMT_MICROMIPS_CVT_D),
		FT, FS, instruction_0);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,00000100,111011:POOL32F:32,f::CVT.L.fmt
"cvt.l.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_cvt_l_fmt (SD_, FMT_MICROMIPS, FT, FS, instruction_0);
}


010101,5.FT,5.FS,5.FD,00110,000000:POOL32F:32,f::CVT.PS.S
"cvt.ps.s f<FD>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_cvt_ps_s (SD_, FD, FS, FT, instruction_0);
}


010101,5.FT,5.FS,0,2.FMT_MICROMIPS_CVT_S!3,1101101,111011:POOL32F:32,f::CVT.S.fmt
"cvt.s.%s<FMT_MICROMIPS_CVT_S> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_cvt_s_fmt (SD_, convert_fmt_micromips_cvt_s (SD_, FMT_MICROMIPS_CVT_S),
		FT, FS, instruction_0);
}


010101,5.FT,5.FS,00,10000100,111011:POOL32F:32,f::CVT.S.PL
"cvt.s.pl f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_cvt_s_pl (SD_, FT, FS, instruction_0);
}


010101,5.FT,5.FS,00,10100100,111011:POOL32F:32,f::CVT.S.PU
"cvt.s.pu f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_cvt_s_pu (SD_, FT, FS, instruction_0);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,00100100,111011:POOL32F:32,f::CVT.W.fmt
"cvt.w.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_cvt_w_fmt (SD_, FMT_MICROMIPS, FT, FS, instruction_0);
}


010101,5.FT,5.FS,5.FD,0,2.FMT_MICROMIPS!2!3,11,110000:POOL32F:32,f::DIV.fmt
"div.%s<FMT_MICROMIPS> f<FD>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_div_fmt (SD_, FMT_MICROMIPS, FD, FS, FT, instruction_0);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,00001100,111011:POOL32F:32,f::FLOOR.L.fmt
"floor.l.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_floor_fmt (SD_, fmt_long, FMT_MICROMIPS, FT, FS);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,00101100,111011:POOL32F:32,f::FLOOR.W.fmt
"floor.w.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_floor_fmt (SD_, fmt_word, FMT_MICROMIPS, FT, FS);
}


010101,5.FT,5.FS,5.FD,5.FR,0,2.FMT_MICROMIPS!3,001:POOL32F:32,f::MADD.fmt
"madd.%s<FMT_MICROMIPS> f<FD>, f<FR>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_madd_fmt (SD_, convert_fmt_micromips (SD_, FMT_MICROMIPS), FD, FR, FS,
	       FT, instruction_0);
}

010101,5.FT,5.FS,0,2.FMT_MICROMIPS!3,0000001,111011:POOL32F:32,f::MOV.fmt
"mov.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_mov_fmt (SD_, convert_fmt_micromips (SD_, FMT_MICROMIPS), FT, FS,
	      instruction_0);
}


010101,5.FT,5.FS,3.CC,00,2.FMT_MICROMIPS!3,00,1.TF,100000:POOL32F:32,f::MOVtf.fmt
"mov%s<TF>.%s<FMT_MICROMIPS> f<FT>, f<FS>, <CC>"
*micromips32:
*micromips64:
{
  do_movtf_fmt (SD_, TF, convert_fmt_micromips (SD_, FMT_MICROMIPS), FT,
		FS, CC);
}


010101,5.FT,5.FS,5.FD,0,2.FMT_MICROMIPS!3,00,111000:POOL32F:32,f::MOVN.fmt
"movn.%s<FMT_MICROMIPS> f<FD>, f<FS>, r<FT>"
*micromips32:
*micromips64:
{
  do_movn_fmt (SD_, convert_fmt_micromips (SD_, FMT_MICROMIPS), FD, FS, FT);
}

010101,5.FT,5.FS,5.FD,0,2.FMT_MICROMIPS!3,01,111000:POOL32F:32,f::MOVZ.fmt
"movz.%s<FMT_MICROMIPS> f<FD>, f<FS>, r<FT>"
*micromips32:
*micromips64:
{
  do_movz_fmt (SD_, convert_fmt_micromips (SD_, FMT_MICROMIPS), FD, FS, FT);
}


010101,5.FT,5.FS,5.FD,5.FR,1,2.FMT_MICROMIPS!3,001:POOL32F:32,f::MSUB.fmt
"msub.%s<FMT_MICROMIPS> f<FD>, f<FR>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_msub_fmt (SD_, convert_fmt_micromips (SD_, FMT_MICROMIPS), FD, FR, FS,
	       FT, instruction_0);
}

010101,5.FT,5.FS,5.FD,0,2.FMT_MICROMIPS!3,10,110000:POOL32F:32,f::MUL.fmt
"mul.%s<FMT_MICROMIPS> f<FD>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_mul_fmt (SD_, convert_fmt_micromips (SD_, FMT_MICROMIPS), FD, FS, FT,
	      instruction_0);
}


010101,5.FT,5.FS,0,2.FMT_MICROMIPS!3,0101101,111011:POOL32F:32,f::NEG.fmt
"neg.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_neg_fmt (SD_, convert_fmt_micromips (SD_, FMT_MICROMIPS), FT, FS,
	      instruction_0);
}


010101,5.FT,5.FS,5.FD,5.FR,0,2.FMT_MICROMIPS!3,010:POOL32F:32,f::NMADD.fmt
"nmadd.%s<FMT_MICROMIPS> f<FD>, f<FR>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_nmadd_fmt (SD_, convert_fmt_micromips (SD_, FMT_MICROMIPS), FD, FR, FS,
		FT, instruction_0);
}

010101,5.FT,5.FS,5.FD,5.FR,1,2.FMT_MICROMIPS!3,010:POOL32F:32,f::NMSUB.fmt
"nmsub.%s<FMT_MICROMIPS> f<FD>, f<FR>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_nmsub_fmt (SD_, convert_fmt_micromips (SD_, FMT_MICROMIPS), FD, FR, FS,
		FT, instruction_0);
}


010101,5.FT,5.FS,5.FD,00010,000000:POOL32F:32,f::PLL.PS
"pll.ps f<FD>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_pll_ps (SD_, FD, FS, FT, instruction_0);
}


010101,5.FT,5.FS,5.FD,00011,000000:POOL32F:32,f::PLU.PS
"plu.ps f<FD>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_plu_ps (SD_, FD, FS, FT, instruction_0);
}


010101,5.FT,5.FS,5.FD,00100,000000:POOL32F:32,f::PUL.PS
"pul.ps f<FD>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_pul_ps (SD_, FD, FS, FT, instruction_0);
}


010101,5.FT,5.FS,5.FD,00101,000000:POOL32F:32,f::PUU.PS
"puu.ps f<FD>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_puu_ps (SD_, FD, FS, FT, instruction_0);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,01001000,111011:POOL32F:32,f::RECIP.fmt
"recip.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_recip_fmt (SD_, FMT_MICROMIPS, FT, FS);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,11001100,111011:POOL32F:32,f::ROUND.L.fmt
"round.l.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_round_fmt (SD_, fmt_long, FMT_MICROMIPS, FT, FS);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,11101100,111011:POOL32F:32,f::ROUND.W.fmt
"round.w.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_round_fmt (SD_, fmt_word, FMT_MICROMIPS, FT, FS);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,00001000,111011:POOL32F:32,f::RSQRT.fmt
"rsqrt.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_rsqrt_fmt (SD_, FMT_MICROMIPS, FT, FS);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,00101000,111011:POOL32F:32,f::SQRT.fmt
"sqrt.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_sqrt_fmt (SD_, FMT_MICROMIPS, FT, FS);
}


010101,5.FT,5.FS,5.FD,0,2.FMT_MICROMIPS!3,01,110000:POOL32F:32,f::SUB.fmt
"sub.%s<FMT_MICROMIPS> f<FD>, f<FS>, f<FT>"
*micromips32:
*micromips64:
{
  do_sub_fmt (SD_, convert_fmt_micromips (SD_, FMT_MICROMIPS), FD, FS, FT,
	      instruction_0);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,10001100,111011:POOL32F:32,f::TRUNC.L.fmt
"trunc.l.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_trunc_fmt (SD_, fmt_long, FMT_MICROMIPS, FT, FS);
}


010101,5.FT,5.FS,0,1.FMT_MICROMIPS,10101100,111011:POOL32F:32,f::TRUNC.W.fmt
"trunc.w.%s<FMT_MICROMIPS> f<FT>, f<FS>"
*micromips32:
*micromips64:
{
  do_trunc_fmt (SD_, fmt_word, FMT_MICROMIPS, FT, FS);
}

001000,5.LWM32REGS,5.BASE,0111,12.OFFSET:POOL32B:64::LDM
"ldm %s<LWM32REGS>, <OFFSET>(r<BASE>)"
*micromips64:
{
  int address_base = GPR[BASE] + EXTEND12 (OFFSET);
  int reg_offset;
  for (reg_offset = 0; reg_offset < (LWM32REGS & 0xf); reg_offset++)
    {
      int dst = (reg_offset == 8) ? 30 : 16 + reg_offset;
      GPR[dst] = EXTEND64 (do_load (SD_, AccessLength_DOUBLEWORD, address_base,
				    8 * reg_offset));
    }

  if (LWM32REGS & 0x10)
    RA = EXTEND64 (do_load (SD_, AccessLength_DOUBLEWORD, address_base,
			    8 * reg_offset));
}

001000,5.RD,5.BASE,0100,12.OFFSET:POOL32B:64::LDP
"ldp r<RD>, <OFFSET>(r<BASE>)"
*micromips64:
{
  if (BASE == RD || RD == 31)
    Unpredictable ();
  else
    {
      check_u64 (SD_, instruction_0);
      GPR[RD] = EXTEND64 (do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE],
				   EXTEND12 (OFFSET)));
      GPR[RD + 1] = EXTEND64 (do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE],
				       EXTEND12 (OFFSET) + 8));
    }
}

001000,5.LWM32REGS,5.BASE,1111,12.OFFSET:POOL32B:64::SDM
"sdm %s<LWM32REGS>, <OFFSET>(r<BASE>)"
*micromips64:
{
  int address_base = GPR[BASE] + EXTEND12 (OFFSET);
  int reg_offset;
  for (reg_offset = 0; reg_offset < (LWM32REGS & 0xf); reg_offset++)
    {
      int src = (reg_offset == 8) ? 30 : 16 + reg_offset;
      do_store (SD_, AccessLength_DOUBLEWORD, address_base, 8 * reg_offset,
		GPR[src]);
    }

  if (LWM32REGS & 0x10)
    do_store (SD_, AccessLength_DOUBLEWORD, address_base, 8 * reg_offset, RA);
}

001000,5.RD,5.BASE,1100,12.OFFSET:POOL32B:64::SDP
"sdp r<RD>, <OFFSET>(r<BASE>)"
*micromips64:
{
  if (RD == 31)
    Unpredictable ();
  else
    {
      check_u64 (SD_, instruction_0);
      do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND12 (OFFSET),
		GPR[RD]);
      do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND12 (OFFSET) + 8,
		GPR[RD + 1]);
    }
}

010110,5.RT,5.RS,5.RD,00,100010000:POOL32S:64::DADD
"dadd r<RD>, r<RS>, r<RT>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dadd (SD_, RD, RS, RT);
}

010110,5.RT,5.RS,10.IMMEDIATE,011100:POOL32S:64::DADDI
"daddi r<RT>, r<RS>, <IMMEDIATE>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_daddi (SD_, RT, RS, IMMEDIATE);
}

010111,5.RT,5.RS,16.IMMEDIATE:MICROMIPS:64::DADDIU
"daddiu r<RT>, r<RS>, <IMMEDIATE>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_daddiu (SD_, RS, RT, IMMEDIATE);
}

010110,5.RT,5.RS,5.RD,00,101010000:POOL32S:64::DADDU
"daddu r<RD>, r<RS>, r<RT>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_daddu (SD_, RS, RT, RD);
}

010110,5.RT,5.RS,0100101100,111100:POOL32S:64::DCLO
"dclo r<RT>, r<RS>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dclo (SD_, RT, RS);
}

010110,5.RT,5.RS,0101101100,111100:POOL32S:64::DCLZ
"dclz r<RT>, r<RS>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dclz (SD_, RT, RS);
}

010110,5.RT,5.RS,1010101100,111100:POOL32S:64::DDIV
"ddiv r<RS>, r<RT>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_ddiv (SD_, RS, RT);
}

010110,5.RT,5.RS,1011101100,111100:POOL32S:64::DDIVU
"ddivu r<RS>, r<RT>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_ddivu (SD_, RS, RT);
}

010110,5.RT,5.RS,5.SIZE,5.LSB,101100:POOL32S:64::DEXT
"dext r<RT>, r<RS>, <LSB>, <SIZE+1>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dext (SD_, RT, RS, LSB, SIZE);
}

010110,5.RT,5.RS,5.SIZE,5.LSB,100100:POOL32S:64::DEXTM
"dextm r<RT>, r<RS>, <LSB>, <SIZE+33>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dextm (SD_, RT, RS, LSB, SIZE);
}

010110,5.RT,5.RS,5.SIZE,5.LSB,010100:POOL32S:64::DEXTU
"dextu r<RT>, r<RS>, <LSB+32>, <SIZE+1>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dextu (SD_, RT, RS, LSB, SIZE);
}

010110,5.RT,5.RS,5.MSB,5.LSB,001100:POOL32S:64::DINS
"dins r<RT>, r<RS>, <LSB>, <MSB-LSB+1>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dins (SD_, RT, RS, LSB, MSB);
}

010110,5.RT,5.RS,5.MSB,5.LSB,000100:POOL32S:64::DINSM
"dinsm r<RT>, r<RS>, <LSB>, <MSB+32-LSB+1>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dinsm (SD_, RT, RS, LSB, MSB);
}

010110,5.RT,5.RS,5.MSB,5.LSB,110100:POOL32S:64::DINSU
"dinsu r<RT>, r<RS>, <LSB+32>, <MSB-LSB+1>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dinsu (SD_, RT, RS, LSB, MSB);
}

010110,5.RT,5.RS,00,3.SEL,00011,111100:POOL32S:64::DMFC0
"dmfc0 r<RT>, r<RS>": SEL == 0
"dmfc0 r<RT>, r<RS>, <SEL>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  DecodeCoproc (instruction_0, 0, cp0_dmfc0, RT, RS, SEL);
}

010101,5.RT,5.FS,00,10010000,111011:POOL32F:64::DMFC1
"dmfc1 r<RT>, f<FS>"
*micromips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  do_dmfc1b (SD_, RT, FS);
}

010110,5.RT,5.RS,00,3.SEL,01011,111100:POOL32S:64::DMTC0
"dmtc0 r<RT>, r<RS>": SEL == 0
"dmtc0 r<RT>, r<RS>, <SEL>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  DecodeCoproc (instruction_0, 0, cp0_dmtc0, RT, RS, SEL);
}

010101,5.RT,5.FS,00,10110000,111011:POOL32F:64::DMTC1
"dmtc1 r<RT>, f<FS>"
*micromips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  do_dmtc1b (SD_, RT, FS);
}

010110,5.RT,5.RS,1000101100,111100:POOL32S:64::DMULT
"dmult r<RS>, r<RT>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dmult (SD_, RS, RT, 0);
}

010110,5.RT,5.RS,1001101100,111100:POOL32S:64::DMULTU
"dmultu r<RS>, r<RT>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dmultu (SD_, RS, RT, 0);
}

010110,5.RT,5.RS,5.SA,00,011000000:POOL32S:64::DROTR
"drotr r<RT>, r<RS>, <SA>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  GPR[RT] = do_dror (SD_, GPR[RS], SA);
}

010110,5.RT,5.RS,5.SA,00,011001000:POOL32S:64::DROTR32
"drotr32 r<RT>, r<RS>, <SA+32>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  GPR[RT] = do_dror (SD_, GPR[RS], SA + 32);
}

010110,5.RT,5.RS,5.RD,00,011010000:POOL32S:64::DROTRV
"drotrv r<RD>, r<RT>, r<RS>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  GPR[RD] = do_dror (SD_, GPR[RT], GPR[RS]);
}

010110,5.RT,5.RS,0111101100,111100:POOL32S:64::DSBH
"dsbh r<RT>, r<RS>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dsbh (SD_, RT, RS);
}

010110,5.RT,5.RS,1111101100,111100:POOL32S:64::DSHD
"dshd r<RT>, r<RS>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dshd (SD_, RS, RT);
}

010110,5.RT,5.RS,5.SA,00,000000000:POOL32S:64::DSLL
"dsll r<RT>, r<RS>, <SA>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dsll (SD_, RS, RT, SA);
}

010110,5.RT,5.RS,5.SA,00,000001000:POOL32S:64::DSLL32
"dsll32 r<RT>, r<RS>, <SA>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dsll32 (SD_, RT, RS, SA);
}

010110,5.RT,5.RS,5.RD,00,000010000:POOL32S:64::DSLLV
"dsllv r<RD>, r<RT>, r<RS>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dsllv (SD_, RS, RT, RD);
}

010110,5.RT,5.RS,5.SA,00,010000000:POOL32S:64::DSRA
"dsra r<RT>, r<RS>, <SA>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dsra (SD_, RS, RT, SA);
}

010110,5.RT,5.RS,5.SA,00,010001000:POOL32S:64::DSRA32
"dsra32 r<RT>, r<RS>, <SA>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dsra32 (SD_, RT, RS, SA);
}

010110,5.RT,5.RS,5.RD,00,010010000:POOL32S:64::DSRAV
"dsrav r<RD>, r<RS>, r<RT>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dsrav (SD_, RS, RT, RD);
}

010110,5.RT,5.RS,5.SA,00,001000000:POOL32S:64::DSRL
"dsrl r<RT>, r<RS>, <SA>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dsrl (SD_, RS, RT, SA);
}

010110,5.RT,5.RS,5.SA,00,001001000:POOL32S:64::DSRL32
"dsrl32 r<RT>, r<RS>, <SA>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dsrl32 (SD_, RT, RS, SA);
}

010110,5.RT,5.RS,5.RD,00,001010000:POOL32S:64::DSRLV
"dsrlv r<RD>, r<RT>, r<RS>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dsrlv (SD_, RS, RT, RD);
}

010110,5.RT,5.RS,5.RD,00,110001000:POOL32S:64::DSUB
"dsub r<RD>, r<RS>, r<RT>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dsub (SD_, RD, RS, RT);
}

010110,5.RT,5.RS,5.RD,00,111001000:POOL32S:64::DSUBU
"dsubu r<RD>, r<RS>, r<RT>"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_dsubu (SD_, RS, RT, RD);
}

110111,5.RT,5.BASE,16.OFFSET:MICROMIPS64:64::LD
"ld r<RT>, <OFFSET>(r<BASE>)"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  GPR[RT] = EXTEND64 (do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE],
			       EXTEND16 (OFFSET)));
}

011000,5.RT,5.BASE,0100,12.OFFSET:POOL32C:64::LDL
"ldl r<RT>, <OFFSET>(r<BASE>)"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  GPR[RT] = do_load_left (SD_, AccessLength_DOUBLEWORD, GPR[BASE],
			  EXTEND12 (OFFSET), GPR[RT]);
}

011000,5.RT,5.BASE,0101,12.OFFSET:POOL32C:64::LDR
"ldr r<RT>, <OFFSET>(r<BASE>)"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  GPR[RT] = do_load_right (SD_, AccessLength_DOUBLEWORD, GPR[BASE],
			   EXTEND12 (OFFSET), GPR[RT]);
}

010101,5.INDEX,5.BASE,5.FD,00,011001000:POOL32F:64,f::LDXC1
"ldxc1 f<FD>, r<INDEX>(r<BASE>)"
*micromips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  COP_LD (1, FD, do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], GPR[INDEX]));
}

011000,5.RT,5.BASE,0111,12.OFFSET:POOL32C:64::LLD
"lld r<RT>, <OFFSET>(r<BASE>)"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_lld (SD_, RT, OFFSET, BASE);
}

011000,5.RT,5.BASE,1111,12.OFFSET:POOL32C:64::SCD
"scd r<RT>, <OFFSET>(r<BASE>)"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_scd (SD_, RT, OFFSET, BASE, 1);
}

110110,5.RT,5.BASE,16.OFFSET:MICROMIPS64:64::SD
"sd r<RT>, <OFFSET>(r<BASE>)"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET),
	    GPR[RT]);
}

011000,5.RT,5.BASE,1100,12.OFFSET:POOL32C:64::SDL
"sdl r<RT>, <OFFSET>(r<BASE>)"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_store_left (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND12 (OFFSET),
		 GPR[RT]);
}

011000,5.RT,5.BASE,1101,12.OFFSET:POOL32C:64::SDR
"sdr r<RT>, <OFFSET>(r<BASE>)"
*micromips64:
{
  check_u64 (SD_, instruction_0);
  do_store_right (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND12 (OFFSET),
		  GPR[RT]);
}

010101,5.INDEX,5.BASE,5.FD,00,100001000:POOL32F:64,f::SDXC1
"sdxc1 f<FD>, r<INDEX>(r<BASE>)"
*micromips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], GPR[INDEX],
	    COP_SD (1, FD));
}
